Source: parallel-hashmap
Section: libs
Priority: optional
#Maintainer: Debian Science Maintainers <debian-science-maintainers@lists.alioth.debian.org>
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Uploaders:
 Steffen Moeller <moeller@debian.org>,
 Andrius Merkys <merkys@debian.org>,
Rules-Requires-Root: no
Build-Depends:
 cmake,
 debhelper-compat (= 13),
 libboost-dev,
 libgmock-dev <!nocheck>,
 libtbb-dev,
Standards-Version: 4.6.2
Homepage: https://github.com/greg7mdp/parallel-hashmap
Vcs-Browser: https://salsa.debian.org/science-team/parallel-hashmap
Vcs-Git: https://salsa.debian.org/science-team/parallel-hashmap.git

Package: libparallel-hashmap-dev
Section: libdevel
Architecture: all
Depends:
 ${misc:Depends},
Suggests:
 libjs-jquery,
 libjs-jquery-flot,
 libjs-jquery-mousewheel,
Description: header-only hash map implementation
 This repository aims to provide a set of excellent hash map
 implementations, as well as a btree alternative to std::map and std::set,
 with the following characteristics:
 .
  * Header only: nothing to build, just copy the parallel_hashmap directory
    to your project and you are good to go.
  * drop-in replacement for std::unordered_map, std::unordered_set,
    std::map and std::set
  * Compiler with C++11 support required, C++14 and C++17 APIs are provided
    (such as try_emplace)
  * Very efficient, significantly faster than your compiler's unordered
    map/set or Boost's, or than sparsepp
  * Memory friendly: low memory usage, although a little higher than
    sparsepp
  * Supports heterogeneous lookup
  * Easy to forward declare: just include phmap_fwd_decl.h in your header
    files to forward declare Parallel Hashmap containers [note: this does
    not work currently for hash maps with pointer keys]
  * Dump/load feature: when a flat hash map stores data that is
    std::trivially_copyable, the table can be dumped to disk and restored
    as a single array, very efficiently, and without requiring any hash
    computation. This is typically about 10 times faster than doing
    element-wise serialization to disk, but it will use 10% to 60% extra
    disk space. See examples/serialize.cc. (flat hash map/set only)
  * Tested on Windows (vs2015 & vs2017, vs2019, Intel compiler 18 and 19),
    linux (g++ 4.8.4, 5, 6, 7, 8, clang++ 3.9, 4.0, 5.0) and MacOS (g++
    and clang++) - click on travis and appveyor icons above for detailed
    test status.
  * Automatic support for boost's hash_value() method for providing the
    hash function (see examples/hash_value.h). Also default hash support
    for std::pair and std::tuple.
